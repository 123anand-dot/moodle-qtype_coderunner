<?php
/** The base class for the coderunner Grader classes.
 *  A Grader is called after running all testcases in a sandbox
 *  to confirm the correctness of the results.
 *  In the simplest subclass, BasicGrader, a test result is correct if
 *  the actual and expected outputs are identical after trailing white space
 *  has been removed. More complicated subclasses can, for example, do
 *  things like regular expression testing.
 */

/**
 * @package    qtype
 * @subpackage coderunner
 * @copyright  Richard Lobb, 2012, The University of Canterbury
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

require_once($CFG->dirroot . '/question/type/coderunner/testingoutcome.php');

abstract class Grader {
    /** Check all outputs, returning an array of TestResult objects.
     * A TestResult is an object with expected, got, isCorrect and grade fields.
     * 'got' and 'expected' fields are sanitised by replacing embedded
     * control characters with hex equivalents and by limiting their
     * lengths to MAX_STRING_LENGTH.
     */

    const MAX_STRING_LENGTH = 8000;

    /** Called to grade the output generated by a student's code for
     *  a given testcase. Returns a single TestResult object.
     */
    abstract function grade(&$output, &$testCase);

    public static function clean(&$s) {
        // A copy of $s with trailing blank lines removed and trailing white
        // space from each line removed. Also sanitised by replacing all control
        // chars with hex equivalents.
        // Used e.g. by BasicGrader subclass.
        // This implementation is a bit algorithmically complex because the
        // original implemention, breaking the string into lines using explode,
        // was a hideous memory hog.
        $nls = '';  // Unused line breaks
        $new_s = '';  // Output string
        $spaces = ''; // Unused space characters
        $n = strlen($s);
        for ($i = 0; $i < $n; $i++) {
            $c = $s[$i];
            if ($c === ' ') {
                $spaces .= $c;
            } elseif ($c === "\n") {
                $spaces = ''; // Discard spaces before a newline
                $nls .= $c;
            } else {
                if ($c < " " || $c > "\x7E") {
                    $c = '\\x' . sprintf("%02x", ord($c));
                }
                $new_s .= $nls . $spaces . $c;
                $spaces = '';
                $nls = '';
            }
        }
        $new_s .= "\n";
        return $new_s;
    }


    public static function snip(&$s) {
        // Limit the length of the given string to MAX_STRING_LENGTH by
        // removing the centre of the string, inserting the substring
        // [... snip ... ] in its place
        $snipInsert = ' ...snip... ';
        $len = strlen($s);
        if ($len > Grader::MAX_STRING_LENGTH) {
            $lenToRemove = $len - Grader::MAX_STRING_LENGTH + strlen($snipInsert);
            $partLength = ($len - $lenToRemove) / 2;
            $firstBit = substr($s, 0, $partLength);
            $lastBit = substr($s, $len - $partLength, $partLength);
            $s = $firstBit . $snipInsert . $lastBit;
        }
        return $s;
    }
}