<?php
/** The base class for the coderunner Grader classes.
 *  A Grader is called after running all testcases in a sandbox
 *  to confirm the correctness of the results.
 *  In the simplest subclass, EqualityGrader, a test result is correct if
 *  the actual and expected outputs are identical after trailing white space
 *  has been removed. More complicated subclasses can, for example, do
 *  things like regular expression testing.
 */

/**
 * @package    qtype
 * @subpackage coderunner
 * @copyright  Richard Lobb, 2012, The University of Canterbury
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

require_once($CFG->dirroot . '/question/type/coderunner/testingoutcome.php');

abstract class qtype_coderunner_grader {
    /** Check all outputs, returning an array of TestResult objects.
     * A TestResult is an object with expected, got, isCorrect and grade fields.
     * 'got' and 'expected' fields are sanitised by replacing embedded
     * control characters with hex equivalents and by limiting their
     * lengths to MAX_STRING_LENGTH.
     */

    const MAX_STRING_LENGTH = 8000;

    /** Called to grade the output generated by a student's code for
     *  a given testcase. Returns a single TestResult object, which
     *  must have called tidy on the expected, output and stdin fields
     *  to limit their lengths.
     */
    function grade(&$output, &$testcase, $isBad = false) {
       if ($isBad) {
            $outcome = new TestResult(
                        qtype_coderunner_grader::tidy($testcase->testcode),
                        $testcase->mark,
                        false,
                        0.0,
                        qtype_coderunner_grader::tidy($testcase->expected),
                        qtype_coderunner_grader::tidy($output),
                        qtype_coderunner_grader::tidy($testcase->stdin),
                        qtype_coderunner_grader::tidy($testcase->extra)
            );
        } else {
            $outcome = $this->gradeKnownGood($output, $testcase);
        }
        return $outcome;
    }


    abstract function gradeKnownGood(&$output, &$testCase);

    // Return a cleaned and snipped version of the string s (or NULL if s is null).
    protected static function tidy($s) {
        if ($s === NULL) {
            return NULL;
        } else {
            $cleanS = qtype_coderunner_grader::clean($s);
            return qtype_coderunner_grader::snip($cleanS);
        }
    }

    protected static function clean(&$s) {
        // A copy of $s with trailing blank lines removed and trailing white
        // space from each line removed. Also sanitised by replacing all control
        // chars except newlines with hex equivalents.
        // A newline terminator is added at the end unless the string to be
        // returned is otherwise empty.
        // Used e.g. by EqualityGrader subclass.
        // This implementation is a bit algorithmically complex because the
        // original implemention, breaking the string into lines using explode,
        // was a hideous memory hog.
        $nls = '';  // Unused line breaks
        $new_s = '';  // Output string
        $spaces = ''; // Unused space characters
        $n = strlen($s);
        for ($i = 0; $i < $n; $i++) {
            $c = $s[$i];
            if ($c === ' ') {
                $spaces .= $c;
            } elseif ($c === "\n") {
                $spaces = ''; // Discard spaces before a newline
                $nls .= $c;
            } else {
                if ($c === "\r") {
                    $c = '\\r';
                } else if ($c === "\t") {
                    $c = '\\t';
                } else if ($c < " " || $c > "\x7E") {
                    $c = '\\x' . sprintf("%02x", ord($c));
                }
                $new_s .= $nls . $spaces . $c;
                $spaces = '';
                $nls = '';
            }
        }
        if ($new_s !== '') {
            $new_s .= "\n";
        }
        return $new_s;
    }


    protected static function snip(&$s) {
        // Limit the length of the given string to MAX_STRING_LENGTH by
        // removing the centre of the string, inserting the substring
        // [... snip ... ] in its place
        $snipInsert = ' ...snip... ';
        $len = strlen($s);
        if ($len > qtype_coderunner_grader::MAX_STRING_LENGTH) {
            $lenToRemove = $len - qtype_coderunner_grader::MAX_STRING_LENGTH + strlen($snipInsert);
            $partLength = ($len - $lenToRemove) / 2;
            $firstBit = substr($s, 0, $partLength);
            $lastBit = substr($s, $len - $partLength, $partLength);
            $s = $firstBit . $snipInsert . $lastBit;
        }
        return $s;
    }
}