'''DFA/NFA quiz prototype'''

import ast
import itertools
import json
import random
import re
import sys


def ensure(cond, error="assertion failed"):
    '''Assertion function'''
    if not cond:
        raise Exception(error)



###############################################
##                                           ##
##    PROGRAM OPTIONS MAY INCLUDE:           ##
##       use student answer                  ##
##       minimal                             ##
##       alpha=x,y,z                         ##
##       nfa                                 ##
##       epsilon                             ##
##                                           ##
###############################################

# Quiz server assignments
OPTIONS_STRING = """{{ TEST.extra | e('py') }}"""
STUDENT_ANSWER_STRING = """{{ STUDENT_ANSWER | e('py') }}"""
CORRECT_ANSWER_STRING = """{{ QUESTION.answer | e('py') }}"""
IS_PRECHECK = "1" == """{{ IS_PRECHECK }}"""



#################################################
##                                             ##
##    SIMPLE TERMINAL TESTING INTERFACE        ##
##                                             ##
##    May be commented out to default to       ##
##    Quiz Server values as assigned above.    ##
##                                             ##
##    Terminal command in the form of:         ##
##    python3 [program].py input.txt           ##
##                                             ##
##    Input text file in the form of:          ##
##    -options                                 ##
##    alpha=0,1,2                              ##
##    minimal                                  ##
##    -answers                                 ##
##    ([[1,3,2],[1,2,1],[1,0,2]],[1,2])        ##
##    ([[1,0,2],[1,2,1],[2,2,2]],[1,2])        ##
##                                             ##
##    Input example of DFA w/o options:        ##
##    -answers                                 ##
##    ([[1,3],[1,2],[2,2],[1,0]],[1])          ##
##    ([[1,0],[1,2],[2,2]],[1])                ##
##                                             ##
##    Input example of NFA:                    ##
##    -options                                 ##
##    nfa                                      ##
##    -answers                                 ##
##    ([[1,3],[1,{2,1}],[{2},2],[1,0]],[1])    ##
##    ([[{1},{0}],[{1},{2,1}],[{2},{2}]],[1])  ##
##                                             ##
##    Input example 2 of NFA:                  ##
##    -options                                 ##
##    nfa                                      ##
##    epsilon                                  ##
##    -answers                                 ##
##    ([[0,1,0],[{1},1,{}]],[1])               ##
##    ([[{1},{0}, 1],[{1},{1},{}]],[1])        ##
##                                             ##
##    Note that the student answer comes       ##
##    first, and then the model answer on      ##
##    the next line.                           ##
##                                             ##
#################################################

# testing interface capability
# may be commented out
# if __name__ == "__main__":
#     file = open(sys.argv[1])
#     OPTIONS_STRING = ""
#     line = file.readline().replace('\n','')
#     if line == "-options":
#         OPTIONS_STRING = file.readline().replace('\n','')
#         line = file.readline().replace('\n','')
#         while line != "-answers":
#             OPTIONS_STRING += "\n" + line
#             line = file.readline().replace('\n','')
#     STUDENT_ANSWER_STRING = file.readline().replace('\n','')
#     CORRECT_ANSWER_STRING = file.readline().replace('\n','')



###############################################
##                                           ##
##    Parse options setting                  ##
##                                           ##
###############################################

# get options input
OPTIONS = OPTIONS_STRING
OPTIONS = OPTIONS.strip().split('\n')



def parse_alpha():
    '''Extracts "alpha=..." from OPTIONS and returns a list of symbols. If
    "alpha=..." does not exist in OPTIONS, ALPHA_LIST defaults to ['0', '1']'''

    alpha = [option for option in OPTIONS if option.startswith('alpha=')]

    if alpha:
        alpha = alpha[0]
        start_pos = alpha.find('=') + 1 # finds index of char after '='
        alpha = ''.join(alpha[start_pos:].split()).split(',')
        ensure(len(alpha) > 0, "empty alphabet")
    else:
        # defaults to:
        alpha = ['0','1']

    return alpha


# automaton alphabet as a list
ALPHA_LIST = parse_alpha()


# automaton type and epsilon check
EPSILON_ENABLED = False
if 'nfa' in OPTIONS:
    AUTOMATON_TYPE = "nfa"
    if 'epsilon' in OPTIONS:
        EPSILON_ENABLED = True
else:
    AUTOMATON_TYPE = "dfa"


# get number of symbols from the length of the ALPHA_LIST
if EPSILON_ENABLED:
    NUMBER_OF_SYMBOLS = len(ALPHA_LIST) + 1
else:
    NUMBER_OF_SYMBOLS = len(ALPHA_LIST)
ensure(1 <= NUMBER_OF_SYMBOLS, "number of symbols is 0")



###############################################
##                                           ##
##    Parse answer and check for             ##
##    lexical, syntactic, and structural     ##
##    errors                                 ##
##                                           ##
###############################################
def find_start_node(edges):
    """Given a list of edges, finds the first-added start edge"""
    start_node_index = -1
    found_start_node = False
    i = 0
    while i < len(edges):
        edge = edges[i]
        if edge[0] == -1:
            if not found_start_node:
                start_node_index = edge[1]
                found_start_node = True
            else:
                raise Exception("Multiple initial states found.") 
        i += 1
    return start_node_index

def parse_student(answer):
    '''Takes an object loaded from JSON, consisting of 4 main parts:
    - nodes
    - edges
    - nodeGeometry
    - edgeGeometry
    We are only concerned with the first two.
    '''
    answer = json.loads(answer)
    nodes = answer["nodes"]
    edges = answer["edges"]
    
    final_states = []
    if AUTOMATON_TYPE == "dfa":
        table = [[None for x in range(NUMBER_OF_SYMBOLS)] for y in range(len(nodes))] 
    else:
        table = [[set() for x in range(NUMBER_OF_SYMBOLS)] for y in range(len(nodes))] 
   
    
    # If startlink is not node 0, we need to fix that
    start_node_index = find_start_node(edges)
    if start_node_index == -1:
        raise Exception("Your representation does not indicate a starting state")
            
    #normalise the start node
    for edge in edges:
        if edge[0] == 0:
            edge[0] = start_node_index
        elif edge[0] == start_node_index:
            edge[0] = 0
            
        if edge[1] == 0:
            edge[1] = start_node_index
        elif edge[1] == start_node_index:
            edge[1] = 0            
    
    # also need to swap nodes in the list
    temp = nodes[0]
    nodes[0] = nodes[start_node_index]
    nodes[start_node_index] = temp
    
    # Build list of final states, AFTER normalisation
    for index, node in enumerate(nodes):
        if node[1]:
            final_states.append(index) 
            
    # Now we need to fill in the empty table
    for edge in edges:
        # essentially, ignore the 'start link'
        if edge[0] != -1:
            from_node = edge[0]
            to_node = edge[1]
            transition = edge[2]
            
            if transition == "":
                # Invalid label
                raise Exception("You are missing a transition label")
            
            # must break up the transition into its components
            transitions = transition.split("|")
            for symbol in transitions:
                # consider ints and epsilons
                if symbol == "\\epsilon" and EPSILON_ENABLED:
                    # last item in list
                    table[from_node][-1] = to_node
                elif symbol == "\\epsilon" and not EPSILON_ENABLED:
                    raise Exception("Cannot use epsilon transitions")
                elif symbol not in ALPHA_LIST:
                    raise Exception("You have used an invalid symbol:" + symbol)
                else:
                    # it's a valid character in the alphabet
                    if AUTOMATON_TYPE == "dfa":
                        if table[int(from_node)][int(symbol)] is None:
                            table[int(from_node)][int(symbol)] = to_node
                        else:
                            raise Exception("Cannot have two transitions in DFA")
                    else:
                        # is NFA
                        current_object = table[int(from_node)][int(symbol)]
                        if current_object == set():
                            table[int(from_node)][int(symbol)] = to_node
                        elif isinstance(current_object, set):
                            table[int(from_node)][int(symbol)].add(to_node)
                        else:
                            new_set = set()
                            new_set.add(table[int(from_node)][int(symbol)])
                            new_set.add(to_node)
                            table[int(from_node)][int(symbol)] = new_set
                            
                
    # now create the text???
    answer_container = "([{0}],[{1}])"
    row_layout = "[{0}]"
    row_strings = []
    
    for row in table:
        this_row = ",".join(str(x) for x in row)
        this_row = this_row.replace("set()", "{}")
        row_strings.append(row_layout.format(this_row))
    rows_text = ",".join(row_strings)
    final_text = ",".join(str(x) for x in final_states)
    answer = answer_container.format(rows_text, final_text)
    
    return parse(answer)
    

def parse(answer):
    '''Parse a DFA/NFA from answer and return a pair of a transition table and a
       list of final states. Raise an exception if this cannot be done.'''

    # error constants
    lexical_error = "There's a lexical error in the automaton representation."
    syntax_error = "There's a syntactic error in the automaton representation."

    # regular expressions for dfa syntax
    num_pair = r'([0-9]+(,[0-9]+)*)'
    dfa_lexical = re.compile(r'^[0-9,()\[\]]*$')
    dfa_row = r'\[[0-9]+(,[0-9]+)*\]'
    dfa_syntax = re.compile(
        r'^\(\[' + dfa_row + r'(,' + dfa_row + r')*\],\[' + num_pair +
        r'?\]\)$')

    # nfa inclusive regular expressions for syntax
    nfa_lexical = re.compile(r'^[0-9,()\[\]\{\}]*$')
    nfa_row = r'([0-9]+|\{' + num_pair + r'*\})'
    nfa_syntax = re.compile(
        r'^\(\[\[' + nfa_row + r'(,' + nfa_row + r')*\](,\[' + nfa_row +
        r'(,' + nfa_row + r')*\])*\],\[' + num_pair + r'?\]\)$')

    answer = answer.strip().replace('\n','').replace('\t','').replace(' ','')
    if AUTOMATON_TYPE == 'nfa':
        ensure(nfa_lexical.match(answer), lexical_error)
        ensure(nfa_syntax.match(answer), syntax_error)
    else:
        ensure(dfa_lexical.match(answer), lexical_error)
        ensure(dfa_syntax.match(answer), syntax_error)

    try:
        table, final = ast.literal_eval(answer)
    except:
        raise Exception(syntax_error)

    # normalize
    # uncomment below print statements to see the changes made
    # print("original:", table)
    for row in table:
        row_len = len(row)
        for i in range(row_len):
            if type(row[i]) == dict:
                row[i] = set()
            elif type(row[i]) == int:
                row[i] = {row[i]}
    # print("normalized:", table)
    return (table, final)

def check_structure(table_final):
    '''Check the structure of a DFA table and final states.'''

    table, final = table_final

    # error constants
    struct_error = "There's a structural error in the automaton representation."

    # check that the table and final states represent a DFA
    number_of_states = len(table)
    ensure(1 <= number_of_states, struct_error)

    for row in table:
        # check that each row has n number of transitions
        # for n = NUMBER_OF_SYMBOLS = length of ALPHA_LIST
        ensure(len(row) == NUMBER_OF_SYMBOLS, struct_error)
        for state_set in row:
            for state in state_set:
                ensure(0 <= state < number_of_states, struct_error)
    for state in final:
        ensure(0 <= state < number_of_states, struct_error)
    return (table, final)

# check student answer for lexical, syntactic, structural correctness
try:
    STUDENT_TABLE, STUDENT_FINAL = check_structure(parse_student(STUDENT_ANSWER_STRING))
except BaseException as exception:
    print(exception)
    sys.exit()

# student answer has parsed without errors

if IS_PRECHECK or "use student answer" in OPTIONS:
    # "use student answer" option is enabled--exit program successfully
    print("Good")
    sys.exit()
else:
    # get model answer input
    CORRECT_ANSWER = CORRECT_ANSWER_STRING
    CORRECT_TABLE, CORRECT_FINAL = parse_student(CORRECT_ANSWER)
    #CORRECT_TABLE, CORRECT_FINAL = parse(CORRECT_ANSWER)



###############################################
##                                           ##
##    Generate test cases                    ##
##                                           ##
###############################################

def generate_test_cases(alpha, low, high=None):
    '''Generates all test cases of lengths between low and high
       composed of symbols from alpha param'''
    if high == None:
        high = low
    test_cases = []
    for length in range(high+1):
        if length == 0:
            new_cases = ['']
        else:
            new_cases = [ s+b for b in alpha for s in new_cases ]
        if low <= length and length <= high:
            test_cases += new_cases
    return test_cases



def generate_special_test_cases(alpha, str_len=50):
    '''Generates special test cases of fixed len str_len,
       including single symbol strings,
       double symbol alternating strings,
       and if size of alpha param is > 2,
       all symbol alternating string forward and reversed'''

    special_cases = []

    for symbol in alpha:
        # single symbol strings of all strings
        special_cases.append(symbol * str_len)

    # double symbol alternating strings of every permutation of len 2
    product_operand = str_len//2
    for item in itertools.permutations(alpha, 2):
        new_str = ""
        for symbol in item:
            new_str += symbol
        special_cases.append(new_str * product_operand)

    # all symbol alternating string, forward and reversed
    if len(alpha) > 2:
        all_symbols_str = ""
        for symbol in alpha:
            all_symbols_str += symbol
        all_symbols_str = (str_len//len(all_symbols_str)) * all_symbols_str
        special_cases.append(all_symbols_str)
        special_cases.append(all_symbols_str[::-1])

    return special_cases



def generate_random_test_cases(n, alpha, low, high=None):
    '''Generates and returns n random strings between length low and high'''

    if high == None:
        high = low

    random_cases = []
    num_symbols = len(alpha)

    #generate n number of random strings between length low and high
    for _ in range(n):
        s_length = random.randint(low, high)
        s = ""
        for _ in range(s_length):
            symbol_index = random.randrange(num_symbols)
            s += alpha[symbol_index]
        random_cases.append(s)
    return random_cases



TESTS = generate_test_cases(ALPHA_LIST, 0, 11) + \
    generate_special_test_cases(ALPHA_LIST) + \
    generate_random_test_cases(50, ALPHA_LIST, 11, 500) + \
    generate_random_test_cases(5, ALPHA_LIST, 5000)


###############################################
##                                           ##
##    Validate answers using                 ##
##    generated test cases                   ##
##                                           ##
###############################################


def epsilon_closure(table, states):
    '''Given a set of states, returns a set of states of their
       epsilon closure, processing up as breadth first search with
       multiple pruning'''
    index = -1 # epsilon transition is always at the last col of the table
    visited_nodes = set()
    working_set = set(states)
    while working_set:
        state = working_set.pop()
        visited_nodes.add(state)
        new_set = table[state][index]
        states.update(new_set)
        working_set.update(new_set - visited_nodes)
    return states



def accepts(table, final, string, alpha):
    '''Checks DFA and NFA
       Assumes that the symbols in table is given/submitted in the
       same order as alpha'''
    states = {0}
    if EPSILON_ENABLED:
        states = epsilon_closure(table, states)
    for symbol in string:
        next_states = set()
        for state in states:
            next_states.update(table[state][alpha.index(symbol)])
        states = next_states
        if EPSILON_ENABLED:
            states = epsilon_closure(table, states)
    valid_end_states = set.intersection(states, final)
    if valid_end_states:
        accepted = True
    else:
        accepted = False
    return accepted



# result string for successful/correct submission
RESULT = "Good"


# if "minimal" option is enabled, check that length of the student
# answer table is correct (the same as the length of the model answer)
if "minimal" in OPTIONS and len(STUDENT_TABLE) != len(CORRECT_TABLE):
    RESULT = "The automaton is not minimal."


# check each test string against the student answer
for test in TESTS:
    try:
        STUDENT_ANSWER = accepts(STUDENT_TABLE, STUDENT_FINAL, test, ALPHA_LIST)
    except BaseException:
        RESULT = "There's an error in the automaton representation."
        break
    CORRECT_ANSWER = accepts(CORRECT_TABLE, CORRECT_FINAL, test, ALPHA_LIST)

    if STUDENT_ANSWER != CORRECT_ANSWER:
        if STUDENT_ANSWER:
            RESULT = "Input '" + test + "' should not be accepted."
        else:
            RESULT = "Input '" + test + "' should be accepted."
        break


# final output
print(RESULT)
