define(['jquery'], function($) {

    function AceGapfillerUi(textareaId, w, h, uiParams) {
        // Constructor for the Ace interface object

        var textarea = $(document.getElementById(textareaId)),
            wrapper = $(document.getElementById(textareaId + '_wrapper')),
            focused = textarea[0] === document.activeElement,
            lang = uiParams.lang,
            session,
            t = this;  // For embedded callbacks.

        let code = "";
        this.uiParams = uiParams;
        this.source = uiParams.ui_source || 'globalextra';
        if (this.source !== 'globalextra' && this.source !== 'test0') {
            alert('Invalid source for code in ui_ace_gapfiller');
            this.source = 'globalextra';
        }
        if (this.source == 'globalextra') {
            code = this.textArea.attr('data-globalextra');
        } else {
            code = this.textArea.attr('data-test0');
        }
        let gaps = [];
        // Extract gaps from source code and insert gaps into editor.
        function reEscape(s) {
            var c, specials = '{[(*+\\', result='';
            for (var i = 0; i < s.length; i++) {
                c = s[i];
                for (var j = 0; j < specials.length; j++) {
                    if (c === specials[j]) {
                        c = '\\' + c;
                    }
                }
                result += c;
            }
            return result;
        }

        let lines = code.split(/\r?\n/);

        let sepLeft = reEscape('{[');
        let sepRight = reEscape(']}');
        let splitter = new RegExp(sepLeft + ' *((?:\\d+)|(?:\\d+- *\\d+)) *' + sepRight);

        let result = "";
        for (let i = 0; i < lines.length; i++) {
            let bits = lines[i].split(splitter);
            result += bits[0];
            
            let columnPos = bits[0].length;
            for (let j = 1; j < bits.length; j += 2) {
                let values = bits[j].split('-');
                let minWidth = parseInt(values[0]);
                let maxWidth = (values.length > 1 ? parseInt(values[1]) : Infinity);
            
                // Create new gap.
                gaps.push(createGap(i, columnPos, minWidth, maxWidth));
                columnPos += minWidth;
                result += ' '.repeat(minWidth);
                if (j + 1 < bits.length) {
                    result += bits[j+1];
                    columnPos += bits[j+1].length;
                }
                
            }

            if (i < lines.length-1) {
                result += '\n';
            }
        }

        try {
            const Range = ace.require("ace/range").Range;
            const fillChar = " ";
            const validChars = /[ !"#$%&'()*+`\-./0-9:;<=>?@A-Z\[\]\\^_a-z{}|~]/

            window.ace.require("ace/ext/language_tools");
            this.modelist = window.ace.require('ace/ext/modelist');

            this.textarea = textarea;
            this.enabled = false;
            this.contents_changed = false;
            this.capturingTab = false;
            this.clickInProgress = false;


            this.editNode = $("<div></div>"); // Ace editor manages this
            this.editNode.css({
                resize: 'none',
                height: h,
                width: "100%"
            });

            this.editor = window.ace.edit(this.editNode.get(0));
            if (textarea.prop('readonly')) {
                this.editor.setReadOnly(true);
            }

            this.editor.setOptions({
                enableBasicAutocompletion: true,
                newLineMode: "unix",
            });
            this.editor.$blockScrolling = Infinity;

            session = this.editor.getSession();
            session.setValue(this.textarea.val());

            // Set theme if available (not currently enabled).
            if (uiParams.theme) {
                this.editor.setTheme("ace/theme/" + uiParams.theme);
            }

            this.setLanguage(lang);

            this.setEventHandlers(textarea);
            this.captureTab();

            // Try to tell Moodle about parts of the editor with z-index.
            // It is hard to be sure if this is complete. ACE adds all its CSS using JavaScript.
            // Here, we just deal with things that are known to cause a problem.
            // Can't do these operations until editor has rendered. So ...
            this.editor.renderer.on('afterRender', function() {
                var gutter =  wrapper.find('.ace_gutter');
                if (gutter.hasClass('moodle-has-zindex')) {
                    return;  // So we only do what follows once.
                }
                gutter.addClass('moodle-has-zindex');

                if (focused) {
                    t.editor.focus();
                    t.editor.navigateFileEnd();
                }
                t.aceLabel = wrapper.find('.answerprompt');
                t.aceLabel.attr('for', 'ace_' + textareaId);

                t.aceTextarea = wrapper.find('.ace_text-input');
                t.aceTextarea.attr('id', 'ace_' + textareaId);
            });

            this.editor.session.setValue(result);


            // Add highlight the gaps.
            for (let gap of gaps) {
                this.editor.session.addMarker(gap.range, "ace-gap-outline", "text", true);
                this.editor.session.addMarker(gap.range, "ace-gap-background", "text", false);
            }

            // Intercept commands sent to ace.
            this.editor.commands.on("exec", function(e) { 
                let cursor = editor.selection.getCursor();
                let commandName = e.command.name;
                selectionRange = editor.getSelectionRange();

                // console.log(selectionRange);
                // console.log(e);
                // console.log(cursor)

                let gap = findCursorGap(cursor);

                if (commandName.startsWith("go")) {  // If command just moves the cursor then do nothing.
                    if (gap != null && commandName === "gotoright" && cursor.column === gap.range.start.column+gap.textSize) {
                        // In this case we jump out of gap over the empty space that contains nothing that the user has entered.
                        t.editor.moveCursorTo(cursor.row, gap.range.end.column+1);
                    } else {
                        return;
                    }   
                }

                if (gap === null) {
                    // Not in a gap

                } else if (t.editor.selection.isEmpty()) {
                    // User is not selecting multiple characters.
                    if (commandName === "insertstring") {
                        let char = e.args;
                        if (validChars.test(char)) {
                            if (gap.textSize == gapWidth(gap) && gapWidth(gap) < gap.maxWidth) {    // Grow the size of gap and insert char.
                                this.changeGapWidth(gap, 1);
                                gap.textSize += 1;  // Important to record that texSize has increased before insertion.
                                t.editor.session.insert(cursor, char);
                            } else if (gap.textSize < gap.maxWidth) {   // Insert char.
                                t.editor.session.remove(new Range(cursor.row, gap.range.end.column-1, cursor.row, gap.range.end.column));
                                gap.textSize += 1;  // Important to record that texSize has increased before insertion.
                                t.editor.session.insert(cursor, char);
                            }
                        }
                    } else if (commandName === "backspace") {
                        if (cursor.column > gap.range.start.column && gap.textSize > 0) {
                            gap.textSize -= 1;
                            t.editor.session.remove(new Range(cursor.row, cursor.column-1, cursor.row, cursor.column));
                            t.editor.moveCursorTo(cursor.row, cursor.column-1);

                            if (gap.textSize >= gap.minWidth) {     
                                this.changeGapWidth(gap, -1);  // Shrink the size of the gap.
                            } else {
                                t.editor.session.insert({row: cursor.row, column: gap.range.end.column-1}, fillChar);   // Put new space at end so everything is shifted across.
                            }
                        }
                    } else if (commandName === "del") {
                        if (cursor.column < gap.range.start.column + gap.textSize && gap.textSize > 0) {
                            gap.textSize -= 1;
                            t.editor.session.remove(new Range(cursor.row, cursor.column, cursor.row, cursor.column+1));

                            if (gap.textSize >= gap.minWidth) {
                                this.changeGapWidth(gap, -1);  // Shrink the size of the gap.
                            } else {
                                t.editor.session.insert({row: cursor.row, column: gap.range.end.column-1}, fillChar); // Put new space at end so everything is shifted across.
                            }
                        }
                    }
                    t.editor.selection.clearSelection(); // Keep selection clear.
                }
                e.preventDefault();
                e.stopPropagation();    
            });

            // Move cursor to where it should be if we click on a gap.
            t.editor.selection.on('changeCursor', function() {
                let cursor = t.editor.selection.getCursor();
                let gap = findCursorGap(cursor);
                if (gap != null) {
                    if (cursor.column > gap.range.start.column+gap.textSize) {
                        t.editor.moveCursorTo(gap.range.start.row, gap.range.start.column+gap.textSize);
                    }
                }
            });

            this.fail = false;
        }
        catch(err) {
            // Something ugly happened. Probably ace editor hasn't been loaded
            this.fail = true;
        }
    }

    // Return if cursor in gap (including end of the gap).
    function cursorInGap(cursor, gap) {
        return (cursor.row >= gap.range.start.row && cursor.column >= gap.range.start.column  && 
                cursor.row <= gap.range.end.row && cursor.column <= gap.range.end.column);
    }

    function gapWidth(gap) {
        return (gap.range.end.column-gap.range.start.column);
    }

    // Return the gap that the cursor is in. This will acutally return a gap if the cursor is 1 outside the gap
    // as this will be needed for backspace/insertion to work. Rigth now this is done as a simple
    // linear search but could be improved later. Returns null if the cursor is not in a gap.
    function findCursorGap(cursor) {
        for (let gap of gaps) {
            if (cursorInGap(cursor, gap)) {
                return gap;
            }
        }
        return null;
    }

    AceGapfillerUi.prototype.changeGapWidth = function(gap, delta) {
        gap.range.end.column += delta;

        // Update any gaps that come after this one on the same line.
        for (let other of gaps) {
            if (other.range.start.row === gap.range.start.row && other.range.start.column > gap.range.end.column) {
                other.range.start.column += delta;
                other.range.end.column += delta;
            }
        }

        this.editor.$onChangeBackMarker();
        this.editor.$onChangeFrontMarker();
    }

    function createGap(row, column, minWidth, maxWidth) {
        let gap = {
            range: new Range(row, column, row, column+minWidth),

            minWidth: minWidth,
            maxWidth: maxWidth,
            textSize: 0
        }
        return gap;
    }


    AceGapfillerUi.prototype.failed = function() {
        return this.fail;
    };

    AceGapfillerUi.prototype.failMessage = function() {
        return 'ace_ui_notready';
    };


    // Sync to TextArea
    AceGapfillerUi.prototype.sync = function() {
        // Nothing to do ... always sync'd
    };

    // Disable autosync, too.
    AceGapfillerUi.prototype.syncIntervalSecs = function() {
        return 0;
    };

    AceGapfillerUi.prototype.setLanguage = function(language) {
        var session = this.editor.getSession(),
            mode = this.findMode(language);
        if (mode) {
            session.setMode(mode.mode);
        }
    };

    AceGapfillerUi.prototype.getElement = function() {
        return this.editNode;
    };

    AceGapfillerUi.prototype.captureTab = function () {
        this.capturingTab = true;
        this.editor.commands.bindKeys({'Tab': 'indent', 'Shift-Tab': 'outdent'});
    };

    AceGapfillerUi.prototype.releaseTab = function () {
        this.capturingTab = false;
        this.editor.commands.bindKeys({'Tab': null, 'Shift-Tab': null});
    };

    AceGapfillerUi.prototype.setEventHandlers = function () {
        var TAB = 9,
            ESC = 27,
            KEY_M = 77,
            t = this;

        this.editor.getSession().on('change', function() {
            t.textarea.val(t.editor.getSession().getValue());
            t.contents_changed = true;
        });

        this.editor.on('blur', function() {
            if (t.contents_changed) {
                t.textarea.trigger('change');
            }
        });

        this.editor.on('mousedown', function() {
            // Event order seems to be (\ is where the mouse button is pressed, / released):
            // Chrome: \ mousedown, mouseup, focusin / click.
            // Firefox/IE: \ mousedown, focusin / mouseup, click.
            t.clickInProgress = true;
        });

        this.editor.on('focus', function() {
            if (t.clickInProgress) {
                t.captureTab();
            } else {
                t.releaseTab();
            }
        });

        this.editor.on('click', function() {
            t.clickInProgress = false;
        });

        this.editor.container.addEventListener('keydown', function(e) {
            if (e.which === undefined || e.which !== 0) { // Normal keypress?
                if (e.keyCode === KEY_M && e.ctrlKey && !e.altKey) {
                    if (t.capturingTab) {
                        t.releaseTab();
                    } else {
                        t.captureTab();
                    }
                    e.preventDefault(); // Firefox uses this for mute audio in current browser tab.
                }
                else if (e.keyCode === ESC) {
                    t.releaseTab();
                }
                else if (!(e.shiftKey || e.ctrlKey || e.altKey || e.keyCode == TAB)) {
                    t.captureTab();
                }
            }
        }, true);
    };

    AceGapfillerUi.prototype.destroy = function () {
        var focused;
        if (!this.fail) {
            // Proceed only if this wrapper was correctly constructed
            focused = this.editor.isFocused();
            this.textarea.val(this.editor.getSession().getValue()); // Copy data back
            this.editor.destroy();
            $(this.editNode).remove();
            if (focused) {
                this.textarea.focus();
                this.textarea[0].selectionStart = this.textarea[0].value.length;
            }
        }
    };

    AceGapfillerUi.prototype.hasFocus = function() {
        return this.editor.isFocused();
    };

    AceGapfillerUi.prototype.findMode = function (language) {
        var candidate,
            filename,
            result,
            candidates = [], // List of candidate modes.
            nameMap = {
                'octave': 'matlab',
                'nodejs': 'javascript',
                'c#': 'cs'
            };

        if (typeof language !== 'string') {
            return undefined;
        }
        if (language.toLowerCase() in nameMap) {
            language = nameMap[language.toLowerCase()];
        }

        candidates = [language, language.replace(/\d+$/, "")];
        for (var i = 0; i < candidates.length; i++) {
            candidate = candidates[i];
            filename = "input." + candidate;
            result = this.modelist.modesByName[candidate] ||
                this.modelist.modesByName[candidate.toLowerCase()] ||
                this.modelist.getModeForPath(filename) ||
                this.modelist.getModeForPath(filename.toLowerCase());

            if (result && result.name !== 'text') {
                return result;
            }
        }
        return undefined;
    };

    AceGapfillerUi.prototype.resize = function(w, h) {
        this.editNode.outerHeight(h);
        this.editNode.outerWidth(w);
        this.editor.resize();
    };

     return {
        Constructor: AceGapfillerUi
    };
});